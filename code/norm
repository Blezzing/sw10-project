./first
[DEBUG] cudaHandler: cuda device initialized
[DEBUG] cudaHandler: cuda context created
[DEBUG] action: generateIR for add action called.
[DEBUG] action: generateIR for add action called.
[DEBUG] vector: ; ModuleID = 'yagalModule'
source_filename = "yagalModule"
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v16:16:16-v32:32:32-v64:64:64-v128:128:128-n16:32:64"
target triple = "nvptx64-nvidia-cuda"

; Function Attrs: nounwind readnone
declare i32 @llvm.nvvm.read.ptx.sreg.tid.x() #0

; Function Attrs: nounwind readnone
declare i32 @llvm.nvvm.read.ptx.sreg.nctaid.x() #0

define ptx_kernel void @kernel(float addrspace(1)* %vec) {
entry:
  %index = alloca i32
  store i32 0, i32* %index
  br label %loop.cond

loop.cond:                                        ; preds = %loop.inc, %entry
  %i6 = load i32, i32* %index, align 4
  %cond = icmp ult i32 %i6, 10
  br i1 %cond, label %bb0, label %loop.end

loop.inc:                                         ; preds = %bb1
  %gdx = call i32 @llvm.nvvm.read.ptx.sreg.nctaid.x()
  %i = load i32, i32* %index, align 4
  %inc = add i32 %i, %gdx
  store i32 %inc, i32* %index
  br label %loop.cond

loop.end:                                         ; preds = %loop.cond
  ret void

bb0:                                              ; preds = %loop.cond
  %i1 = load i32, i32* %index, align 4
  %ptr = getelementptr float, float addrspace(1)* %vec, i32 %i1
  %tmp = load float, float addrspace(1)* %ptr, align 4
  %ret = fadd float %tmp, 5.000000e+00
  store float %ret, float addrspace(1)* %ptr, align 4
  br label %bb1

bb1:                                              ; preds = %bb0
  %i2 = load i32, i32* %index, align 4
  %ptr3 = getelementptr float, float addrspace(1)* %vec, i32 %i2
  %tmp4 = load float, float addrspace(1)* %ptr3, align 4
  %ret5 = fadd float %tmp4, 5.000000e+00
  store float %ret5, float addrspace(1)* %ptr3, align 4
  br label %loop.inc
}

attributes #0 = { nounwind readnone }

!nvvm.annotations = !{!0}

!0 = !{void (float addrspace(1)*)* @kernel, !"kernel", i32 1}

[DEBUG] vector: //
// Generated by LLVM NVPTX Back-End
//

.version 3.2
.target sm_20
.address_size 64

	// .globl	kernel

.visible .entry kernel(
	.param .u64 kernel_param_0
)
{
	.reg .pred 	%p<2>;
	.reg .f32 	%f<4>;
	.reg .b32 	%r<6>;
	.reg .b64 	%rd<4>;

	mov.u32 	%r5, 0;
	ld.param.u64 	%rd1, [kernel_param_0];
	mov.u32 	%r4, %nctaid.x;
	setp.lt.u32 	%p1, %r5, 10;
	@%p1 bra 	LBB0_3;
	bra.uni 	LBB0_2;
LBB0_3:
	mul.wide.s32 	%rd2, %r5, 4;
	add.s64 	%rd3, %rd1, %rd2;
	ld.global.f32 	%f1, [%rd3];
	add.rn.f32 	%f2, %f1, 0f40A00000;
	add.rn.f32 	%f3, %f2, 0f40A00000;
	st.global.f32 	[%rd3], %f3;
	add.s32 	%r5, %r5, %r4;
	setp.lt.u32 	%p1, %r5, 10;
	@%p1 bra 	LBB0_3;
LBB0_2:
	ret;
}



[INFO] cudaHandler: cuda kernel launching
[INFO] cudaHandler: cuda kernel executed successfully
[DEBUG] action: generateIR for add action called.
[DEBUG] action: generateIR for add action called.
[DEBUG] vector: ; ModuleID = 'yagalModule'
source_filename = "yagalModule"
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v16:16:16-v32:32:32-v64:64:64-v128:128:128-n16:32:64"
target triple = "nvptx64-nvidia-cuda"

; Function Attrs: nounwind readnone
declare i32 @llvm.nvvm.read.ptx.sreg.tid.x() #0

; Function Attrs: nounwind readnone
declare i32 @llvm.nvvm.read.ptx.sreg.nctaid.x() #0

define ptx_kernel void @kernel(float addrspace(1)* %vec) {
entry:
  %index = alloca i32
  store i32 0, i32* %index
  br label %loop.cond

loop.cond:                                        ; preds = %loop.inc, %entry
  %i6 = load i32, i32* %index, align 4
  %cond = icmp ult i32 %i6, 10
  br i1 %cond, label %bb2, label %loop.end

loop.inc:                                         ; preds = %bb3
  %gdx = call i32 @llvm.nvvm.read.ptx.sreg.nctaid.x()
  %i = load i32, i32* %index, align 4
  %inc = add i32 %i, %gdx
  store i32 %inc, i32* %index
  br label %loop.cond

loop.end:                                         ; preds = %loop.cond
  ret void

bb2:                                              ; preds = %loop.cond
  %i1 = load i32, i32* %index, align 4
  %ptr = getelementptr float, float addrspace(1)* %vec, i32 %i1
  %tmp = load float, float addrspace(1)* %ptr, align 4
  %ret = fadd float %tmp, 5.000000e+00
  store float %ret, float addrspace(1)* %ptr, align 4
  br label %bb3

bb3:                                              ; preds = %bb2
  %i2 = load i32, i32* %index, align 4
  %ptr3 = getelementptr float, float addrspace(1)* %vec, i32 %i2
  %tmp4 = load float, float addrspace(1)* %ptr3, align 4
  %ret5 = fadd float %tmp4, 5.000000e+00
  store float %ret5, float addrspace(1)* %ptr3, align 4
  br label %loop.inc
}

attributes #0 = { nounwind readnone }

!nvvm.annotations = !{!0}

!0 = !{void (float addrspace(1)*)* @kernel, !"kernel", i32 1}

[DEBUG] vector: //
// Generated by LLVM NVPTX Back-End
//

.version 3.2
.target sm_20
.address_size 64

	// .globl	kernel

.visible .entry kernel(
	.param .u64 kernel_param_0
)
{
	.reg .pred 	%p<2>;
	.reg .f32 	%f<4>;
	.reg .b32 	%r<6>;
	.reg .b64 	%rd<4>;

	mov.u32 	%r5, 0;
	ld.param.u64 	%rd1, [kernel_param_0];
	mov.u32 	%r4, %nctaid.x;
	setp.lt.u32 	%p1, %r5, 10;
	@%p1 bra 	LBB0_3;
	bra.uni 	LBB0_2;
LBB0_3:
	mul.wide.s32 	%rd2, %r5, 4;
	add.s64 	%rd3, %rd1, %rd2;
	ld.global.f32 	%f1, [%rd3];
	add.rn.f32 	%f2, %f1, 0f40A00000;
	add.rn.f32 	%f3, %f2, 0f40A00000;
	st.global.f32 	[%rd3], %f3;
	add.s32 	%r5, %r5, %r4;
	setp.lt.u32 	%p1, %r5, 10;
	@%p1 bra 	LBB0_3;
LBB0_2:
	ret;
}



[INFO] cudaHandler: cuda kernel launching
[INFO] cudaHandler: cuda kernel executed successfully
[INFO] vector: 20 21 22 23 24 25 26 27 28 29 
